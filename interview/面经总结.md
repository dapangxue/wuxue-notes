# 系统设计

### 1、什么是微服务？

微服务是近几年来比较火的一个概念，它是以开发一组小型服务的方式来组成一个独立的大型的应用系统，各个小型服务独自运行，相互之间通过轻量级通信机制保证通信。这些服务可以使用不同的语言、不同的数据库。

单个的微服务通常完成一个独立的功能，比如用户管理，订单管理等等。

微服务开发的优点就是：
+ 易于开发和维护
+ 功能独立
+ 局部修改容易部署
+ 技术栈不受限
+ 按需伸缩

相对于微服务，传统的单体应用的缺点也就暴露了出来，单体应用在体量小时尚可，系统越来越大后，问题也就暴露了出来。有两个关键点：
+ 牵一发而动全身，如果修改了一小部分代码，也需要停机，部署完成后重新启动。
+ 只能水平扩展，不能纵向扩展，当发现某一业务的请求量巨大时，无法单独扩展该业务，必须将整个单体应用扩展。

### 2、SpringCloud有什么组件？

SpringCloud组件有:
+ 服务注册于发现的Eureka
+ 服务消费者的（RestTemplate + Ribbon）和Feign
+ 用于服务熔断的Hystrix,避免连锁故障
+ 路由网关Zuul

### 3、分布式Session的解决方案

+ ip_hash
将客户端用户的ip和访问的服务器绑定在一起，也就是将用户粘在特定的后台服务器上。
+ 服务器Session复制
如果一台服务器的Session发生了改变，那么这台服务器结点将这条Session的所有内容序列化，广播到其他的服务器。
Tomcat中可以配置这种方式。
+ Session共享
两种方案，粘性session和非粘性session。
通过Redis或者memcached缓存。粘性session就是每个服务器结点对应不同的缓存结点，服务器产生Session，并将其缓存到对应的缓存结点。如果一个服务器结点挂掉，访问到其他服务器结点后，可以从缓存中拿Session。
非粘性session方案就是将Tomcat产生session,将session写入缓存，获取session也从缓存中获取，服务器不保存session。
+ Session持久化
+ Terracotta实现Session复制
如果一个结点的Session发生变化，Terracotta将变化的那一部分发送给Terracotta服务器，服务器把它转发给真正需要的结点。

### 4、线程池怎么合理的配置（拼多多）

可以根据任务的性质合理区分，比如对于I/O密集型任务，并不是一直都在执行任务，所以线程数可以配置的大点，比如（2×CPU的个数）。对于CPU密集型的任务，配置尽可能小的线程数比如（CPU的个数+1）个。

如果任务有优先级，可以根据优先级队列PriorityBlockingQueue来处理。

任务的执行时间不同也可以采用不同规模的线程池处理，或者采用优先级队列处理。

依赖数据库连接池的任务，线程提交SQL需要等待结果返回，等待时间越长，CPU越空闲，线程数可以设置的大点，这样才能更好的利用CPU。

任务的工作队列采用有界阻塞队列。

### 5、数据库的分库分表

#### 水平拆分

水平Sharding的策略：

+ 映射表：单独维护一个库，用于存储ID和表的映射关系
+ 范围：根据ID划分范围，或者是时间范围
+ 哈希取模

映射表的优点就是ID和库的mapping算法可以修改，缺点是需要单独维护一个库。
范围拆分的优点就是单表大小可控，天然的水平扩展，缺点就是无法解决集中写入瓶颈的问题，热点数据一般都在一张表内
哈希取模可以做到热点数据分开。

垂直切分策略：

将一张表按照列切分为多个表，通常按照列的密集关系进行切分，也可以将经常使用的列和不经常使用的列进行拆分。

垂直拆分的优点就是使得数据变小，一个数据块就能存放更多的数据，查询时减少I/O次数。缺点是表的join操作会增加CPU的开销，也可以通过在业务服务器上进行join操作，来缓解数据库服务器的压力，依然存在单表数据量过大的问题。


### 6、数据库的范式

+ 第一范式：数据库的每一列都是不可再分割的，保证每一列的原子性。
+ 第二范式：一行数据只能和一列相关，即一行数据只能做一件事。即表中必须要有主键，没有包含在主键中的列必须完全依赖主键，而不是依赖主键的一部分。不满足第二范式容易产生冗余数据。
+ 第三范式：非主键列不能存在传递关系，每个属性必须和主键有直接关系，而不是间接关系。

对于第三范式的解释，比如对于一张表Student，表中的字段有学号、姓名、年龄、性别、所在院校、院校地址、院校电话，在这个表结构中，存在的关系依赖有：学号->所在院校->院校地址、院校电话

上述例子存在间接依赖，需要将数据表拆分成两块（学号、姓名、年龄、性别、所在院校）和（院校、院校地址、院校电话）。

### 7、Redis的持久化

Redis提供了两种持久化的方式：RDB snapshot和AOF增量型持久化，快照是一次全量备份，而AOF是增量型的备份。快照备份的数据形式是二进制序列化形式，存储紧凑。AOF日志记录的是内存数据修改的指令集文本。

快照持久化采用的Copy On Write机制，它本身是单线程的程序，应对多个客户端并发读写的同时，还需要进行快照的持久化到文件，它会fork一个子进程，子进程负责持久化，父进程应对客户端的读写，父子进程共享数据块和代码块，如果父进程对Redis中的页面进行修改时，会将共享的页面复制一份出来，然后对复制的页面进行修改，这是子进程相应的页面是没有变化的。

快照持久化在Redis故障以后会丢失最后一次快照以后的数据。

AOF增量型的备份将修改性的指令追加到AOF文件的末尾，AOF的需要设置同步选项，确保写命令将修改性指令同步到磁盘的时机。因为对数据进行修改的指令不会马上同步到磁盘，而是先缓存到缓存区，由操作系统确定什么时候同步到磁盘。

| 选项 | 同步帧率 |
| ------ | ------ |
| always | 每个写命令同步 |
| everysec | 每秒同步一次 |
| no | 让操作系统决定何时同步 |

+ always严重降低了服务器的性能
+ everysec选项比较合适，可以保证系统崩溃时，只丢失一秒左右的数据，并且这个选项对Redis的性能影响较小
+ no并不能给Redis服务器带来多大的性能提升，也会增加系统崩溃时数据丢失的数量。

随着命令的增加，AOF备份文件会越来越大，所以Redis会对备份文件进行瘦身。

### 7.MySQL中的锁

MySQL中的锁分为服务层实现的锁（Lock Tables、全局读锁、命名锁、字符锁）和基于存储引擎实现的锁（Innodb的行锁表锁和myisam的表锁）。

MySQL按照锁的粒度可以分为行锁和表锁。修改时应该尽量锁定只修改的那部分数据，提高数据库的并发量。但是锁的操作（加锁、解锁、检查锁的状态）都会增加系统的开销，锁的粒度越小，开销就越大。

按照的锁的类型，可以将锁分为读锁和写锁。读锁为共享锁，写锁为排它锁。

MySQL中优化了加锁的机制，引入了意向锁，假设事务A需要给表加写锁，需要先检测其他事务是否给表加了行锁/表锁，这样需要对表每一行进行遍历检测，相当耗时，意向锁（intention lock）就是在原来共享锁/独占锁的基础上加了IS/IX，这两种意向锁都是表锁。也就有了如下规定：
+ 一个事务在获取X锁之前，需要先获取该表的IX锁。
+ 一个事务在获取S锁之前，需要先获取该表的IS锁。

在有了意向锁之后，如果一个事务想要给一张表添加X锁，那么首先判断其他事务是否给该表添加了S/X/IS/IX锁，如果添加了，那么表示已经有锁添加到该表，也就不能再添加其他X锁了。

任意的意向锁都是兼容的，它们只表示了想要对表加锁，并不会真正的加锁。

### 8.MySQL的查询优化

MySQL表中数据量大时，需要限制查询条数，以及做翻页优化。直接使用LIMIT关键字，比如

```SQL
# 假设当前数据库有700W条数据，需要查询第1000000~1000100条数据
SELECT *FROM table_name LIMIT 1000000,100;

# 执行EXPLAIN语句分析发现，涉及到的行是这张表的所有行，相当于全表查询所有数据，然后跳过角标offset,取特定的数据
```

在id连续的情况下，如果采用了where子句引入索引查询，速度会加快。

```SQL
SELECT * FROM table_name WHERE id > 6000000 AND id < 6000100;
```

或者采用Between

```SQL
SELECT * FROM table_name WHERE id BETWEEN 6000000 AND 6000100
```

### 9.什么是Full GC？

针对HotSpot VM虚拟机而言，GC只有两种：
+ Partial GC:并不是收集整个GC堆
+ Full GC:收集整个GC堆

对于Partial GC，可以分为：
+ Young GC，只收集Young Gen的过程
+ Old GC，只收集Old Gen的GC过程，只有CMS的Concurrent Collection是这个模式
+ Mixed GC，收集整个Young Gen和部分Old Gen的过程。只有G1是这个模式

Young GC的触发时机：当Young Gen中的eden区分配满的时候触发。在进行Young GC的时候会有一部分存活对象满足进入老年代空间的对象进入Old Gen，所以在进行Young GC的时候，Old Gen的容量会有所升高。

为什么选择在eden区满的时候触发Young GC，而不是在From Survivor + Eden区满的时候进行收集，主要是因为survivor区其实都是中间年龄层对象的过渡区域，新对象的创建往往都在Eden区域，survivor space的存在都是为了让中间年龄层的对象不要过早的晋升入Old Gen。

Old GC的触发时机：准备触发Young GC的时候，如果虚拟机统计数据发现，Young GC的平均晋升大小比目前Old Gen的剩余空间大，则不会触发Young GC而是转向触发Full GC（为什么是Full GC而不是Old GC，是因为除了CMS的concurrent collection外，其他的垃圾收集器会同时触发Young GC和Full GC），如果存在perm Gen的话，要在Perm Gen分配空间但是空间不够时，也会触发Full GC。除此之外，还有System.gc()也会触发Full GC.

## 参考文档

+ [大众点评订单系统分库分表实践](https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html)
+ [数据库设计范式](https://www.cnblogs.com/knowledgesea/p/3667395.html)
+ [Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/search?type=content&q=full%20GC)
